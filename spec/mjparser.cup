
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;

	Logger log = Logger.getLogger(getClass());

    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
    	done_parsing();
    	report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
		
:}

init with {:
	errorDetected = false;
:}

scan with {:

	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}



terminal Boolean BOOL;
terminal Integer NUMBER;
terminal String IDENT;
terminal Character CHAR;

nonterminal ActPars, ActParsParens, Addop, Assignop;
nonterminal Condition, CondFact, ConditionIf, CondTerm;
nonterminal ConstAssign, ConstDecl, ConstList;
nonterminal DesignatorStatement, FormPar;
nonterminal FormPars, FormParsParens, FunctionCall, Label, Matched, MethodTypeAndName;
nonterminal MethodDecl, MethodDeclList, Mulop;
nonterminal ProgHeadList, ProgHead, Relop, Statement, StatementList;
nonterminal Unmatched, VarDecl, VarDeclList, VarList;

terminal AND, BEQ, BREAK;
terminal CLASS, COMMA, CONST, CONT, DECR;
terminal DOT, ELSE, EQ, EQUAL, EXTENDS;
terminal IF, INCR, LAMBDA, LANGLE, LBRACE;
terminal LBRACKET, LEQ, LPAREN, MAP, MINUS;
terminal NEQ, NEW, OR, PERCENT;
terminal PLUS, PRINT, PROGRAM, RANGLE, RBRACE;
terminal RBRACKET, READ, RETURN, RPAREN, SEMI;
terminal SLASH, STAR, VOID, WHILE;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator, VarDeclSingle, ProgName, Program;

nonterminal rs.etf.pp1.symboltable.concepts.Struct ConstOne, Expr, Factor, Term, Type;


Program ::= (Program) PROGRAM ProgName:p ProgHeadList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

ProgHeadList ::= ProgHeadList ProgHead
			|
			;

ProgHead ::= VarDecl
			|
			ConstDecl;

ConstDecl ::= (ConstDecl) CONST Type ConstList SEMI;

ConstOne ::= (ConstOneNumber) NUMBER
			|
			(ConstOneBool) BOOL
			|
			(ConstOneChar) CHAR;

ConstList ::= ConstList COMMA ConstAssign
			|
			ConstAssign;

ConstAssign ::= (ConstAssign) IDENT:name EQUAL ConstOne;

VarDeclList ::= VarDeclList VarDecl
			|
			;

VarDecl ::= Type VarList SEMI;

VarList ::= VarList COMMA VarDeclSingle
		|
		VarDeclSingle;

VarDeclSingle ::= (VarDeclScalar) IDENT:name
				|
				(VarDeclArray) IDENT:name LBRACKET RBRACKET
				|
				(VarDeclMatrix) IDENT:name LBRACKET RBRACKET LBRACKET RBRACKET;

MethodDeclList ::= MethodDeclList MethodDecl
				|
				;

MethodDecl ::= (MethodDecl) MethodTypeAndName FormParsParens VarDeclList LBRACE StatementList RBRACE;

MethodTypeAndName ::= (MethodTypeAndNameNonvoid) Type IDENT:name
			|
			(MethodTypeAndNameVoid) VOID IDENT:name;

FormPars ::= FormPars COMMA FormPar
			|
			FormPar;

FormParsParens ::= LPAREN FormPars RPAREN
				|
				LPAREN RPAREN;

FormPar ::= (FormParScalar) Type IDENT:name
		|
		(FormParArray) Type IDENT:name LBRACKET RBRACKET
		|
		(FormParMatrix) Type IDENT:name LBRACKET RBRACKET LBRACKET RBRACKET;

Type ::= (Type) IDENT:typeName;

Statement ::= Matched
			|
			Unmatched;

Unmatched ::= IF ConditionIf Statement
			|
			IF ConditionIf Matched ELSE Unmatched
			|
			WHILE ConditionIf Unmatched;

Matched ::= DesignatorStatement SEMI
			|
			IF ConditionIf Matched ELSE Matched
			|
			WHILE ConditionIf Matched
			|
			BREAK SEMI
			|
			CONT SEMI
			|
			(MatchedReturnExpr) RETURN Expr SEMI
			|
			RETURN SEMI
			|
			READ LPAREN Designator RPAREN SEMI
			|
			PRINT LPAREN Expr RPAREN SEMI
			|
			PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI
			|
			Designator DOT MAP LPAREN IDENT LAMBDA Statement RPAREN SEMI
			|
			LBRACE StatementList RBRACE;
			
StatementList ::= StatementList Statement
				|
				;

DesignatorStatement ::= (DesignatorStatementAssign) Designator Assignop Expr
					|
					(DesignatorStatementFuncCall) FunctionCall
					|
					(DesignatorStatementIncr) Designator INCR
					|
					(DesignatorStatementDecr) Designator DECR;

ActPars ::= ActPars COMMA Expr
		|
		Expr;

FunctionCall ::= (FunctionCall) Designator ActParsParens;

ActParsParens ::= LPAREN ActPars RPAREN
				|
				LPAREN RPAREN;

ConditionIf ::= LPAREN Condition RPAREN
			|
			LPAREN error RPAREN:l {: parser.report_error("Izvr≈°en oporavak do ')' za IF/WHILE u liniji " + lleft, null); :};

Condition ::= Condition OR CondTerm
			|
			CondTerm;

CondTerm ::= CondTerm AND CondFact
		|
		CondFact;

CondFact ::= (CondFactRelop) Expr Relop Expr
		|
		(CondFactExpr) Expr;

Expr ::= (ExprAddop) Expr Addop Term
		|
		(ExprNegative) MINUS Term
		|
		(ExprTerm) Term;

Term ::= (TermMulop) Term Mulop Factor
		|
		(TermFactor) Factor;

Factor ::= (FactorDesignator) Designator
		|
		(FactorFuncCall) FunctionCall
		|
		(FactorConst) ConstOne
		|
		(FactorNewArray) NEW Type LBRACKET Expr RBRACKET
		|
		(FactorNewMatrix) NEW Type LBRACKET Expr RBRACKET LBRACKET Expr RBRACKET
		|
		(FactorExpr) LPAREN Expr RPAREN;

Designator ::= (DesignatorName) IDENT:name
			|
			(DesignatorArray) Designator LBRACKET Expr RBRACKET;

Label ::= IDENT;

Assignop ::= EQUAL;

Relop ::= (RelopEQ) EQ
		|
		(RelopNEQ) NEQ
		|
		RANGLE
		|
		BEQ
		|
		LANGLE
		|
		LEQ;

Addop ::= PLUS 
		|
		MINUS;

Mulop ::= STAR
		|
		SLASH
		|
		PERCENT;

